# https://leetcode.com/problems/minimize-malware-spread-ii/description/

from typing import List
import collections

class Solution:
    def dfs(self, grafo: List[List[int]], visitado: set, inicio: int, responsaveis: dict, infectado_por: int):
        # Implementação da DFS iterativa usando uma pilha
        pilha = [inicio]
        while pilha:
            no_atual = pilha.pop()  # Explora o último nó inserido (busca em profundidade)
            for vizinho in range(len(grafo[no_atual])):
                if grafo[no_atual][vizinho] == 1 and vizinho not in visitado:
                    visitado.add(vizinho)  # Marca o nó vizinho como visitado
                    responsaveis[vizinho].append(infectado_por)  # Registra quem infectou o vizinho
                    pilha.append(vizinho)  # Adiciona o vizinho à pilha para explorar mais tarde

    def minMalwareSpread(self, grafo: List[List[int]], inicial: List[int]) -> int:
        n = len(grafo)
        responsaveis = collections.defaultdict(list)  # Mapeia cada nó para os nós iniciais que o infectaram

        # Propagação do malware para cada nó inicial usando DFS
        for infectado_inicial in inicial:
            visitado = set(inicial)  # Considera todos os nós em 'inicial' como já infectados
            self.dfs(grafo, visitado, infectado_inicial, responsaveis, infectado_inicial)

        # Calcula o impacto de cada nó infectado
        impacto = [0] * n
        for no, lista_responsaveis in responsaveis.items():
            if len(lista_responsaveis) == 1:  # Verifica se apenas um nó inicial foi responsável pela infecção
                infectado_responsavel = lista_responsaveis[0]
                impacto[infectado_responsavel] += 1  # Incrementa o impacto desse nó inicial

        # Identifica o nó com o maior impacto (ou o menor índice em caso de empate)
        max_impacto = max(impacto)
        if max_impacto == 0:
            return min(inicial)  # Caso nenhum nó tenha impacto exclusivo, retorna o de menor índice
        return impacto.index(max_impacto)

# Casos de teste

# solution = Solution()
# print(solution.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1]))  # Saída esperada: 0
# print(solution.minMalwareSpread([[1,1,0],[1,1,1],[0,1,1]], [0,1]))    # Saída esperada: 1
# print(solution.minMalwareSpread([[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], [0,1]))  # Saída esperada: 1