# https://leetcode.com/problems/minimize-malware-spread-ii/description/

from typing import List

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # Função de DFS usando pilha para explorar o componente conectado a partir de um nó
        def dfs(no_inicial):
            pilha = [no_inicial]  # Inicializa a pilha com o nó inicial
            componente = []       # Lista para armazenar os nós do componente conectado
            visitado[no_inicial] = True  # Marca o nó inicial como visitado
            while pilha:
                no_atual = pilha.pop()  # Remove o nó do topo da pilha
                componente.append(no_atual)  # Adiciona o nó ao componente
                # Percorre todos os possíveis vizinhos do nó atual
                for vizinho in range(len(graph)):
                    # Se o vizinho é conectado (1) e não foi visitado, o adicionamos à pilha
                    if graph[no_atual][vizinho] == 1 and not visitado[vizinho]:
                        pilha.append(vizinho)
                        visitado[vizinho] = True  # Marca o vizinho como visitado
            return componente
        
        # Função para contar o número de nós que podem ser infectados no componente
        def conta_infectados(componente):
            infectados = 0
            for no in componente:
                if no in infectados_iniciais:
                    infectados += 1
            return infectados
        
        # Inicializando as variáveis
        visitado = [False] * len(graph)  # Marca nós visitados
        infectados_iniciais = set(initial)  # Converte a lista inicial para conjunto
        melhor_no = min(initial)  # O melhor nó começa como o menor índice de `initial`
        melhor_impacto = float('inf')  # Começamos com um impacto "infinito"
        
        # Ordena os nós infectados inicialmente para garantir que o menor índice seja considerado em caso de empate
        initial.sort()
        
        # Para cada nó infectado, exploramos seu componente conectado
        for no_inicial in initial:
            if not visitado[no_inicial]:
                # DFS com pilha para explorar todos os nós conectados ao nó inicial
                componente = dfs(no_inicial)
                
                # Verifica quantos infectados iniciais estão neste componente
                infectados = conta_infectados(componente)
                
                # Se houver apenas 1 infectado neste componente, podemos considerar removê-lo
                if infectados == 1:
                    # Calcula o tamanho do componente (número de nós que seriam salvos)
                    impacto = len(componente)
                    # Atualiza o melhor nó se este impacto for maior
                    if impacto > melhor_impacto or (impacto == melhor_impacto and no_inicial < melhor_no):
                        melhor_impacto = impacto
                        melhor_no = no_inicial
        
        return melhor_no

# Exemplos de teste
# solution = Solution()
# print(solution.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1]))  # Saída esperada: 0
# print(solution.minMalwareSpread([[1,1,0],[1,1,1],[0,1,1]], [0]))    # Saída esperada: 1
# print(solution.minMalwareSpread([[1,1,0,0,0],[1,1,1,0,0],[0